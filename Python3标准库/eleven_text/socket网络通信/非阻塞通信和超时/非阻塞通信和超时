默认的,socket被配置为发送或接收数据时会阻塞,在套接字准备就绪之前将停止程序的执行.
send()调用等待有缓冲区空间来存放发出的数据,recv()则等待其他程序发出数据来读取.
这种形式的I/O操作很容易理解,不过可能导致操作很低效,如果两个程序在最后都在等待对方
发出或接受数据,那么可能会导致死锁.
有很多方法来绕开这种情况.一种做法是对各个套接字分别使用单独的线程完成通信.不过这
可能引入线程间通信的其他复杂性.另一种选择是将套接字改为根本不阻塞,即使没有准备好
来处理操作,也会立即返回.可以使用setblocking()方法改变一个套接字的阻塞标志.默认值为1,
这表示会阻塞.传入值0则会关闭阻塞.如果套接字将阻塞关闭,而且没有为处理操作做好准备,则会
产生一个socket.error.
一种折中的解决方案是为套接字操作设置一个超时值.可以使用settimeout()将socket的超时值
改为一个浮点值,表示确定这个套接字为做好操作准备之前所阻塞的时间.超过这个超时期限时,
会产生一个timeout异常.
